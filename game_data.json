{"name": "Learning Lean Through Introductory Group Theory", "version": "1.0.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Learning Lean Through Introductory Group Theory-1.0.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 5, "objects": [{"type": "text", "content": "3"}, {"type": "lean", "content": "4", "hidden": false}, {"type": "text", "content": "5"}, {"type": "lean", "content": "6", "hidden": false}, {"type": "text", "content": "7"}, {"type": "lemma", "text": "8", "lean": "theorem mul_left_cancel(a b c : G)(h1: a*b=a*c): b=c :=\n", "sideBar": true, "firstProofLineNumber": 38, "lastProofLineNumber": 44, "textBefore": "/-\n# Proving left cancellation.\n\n\nOur first goal is to prove that we have left cancellation in a group. \n\nMore precisely, given elements $a$, $b$, and $c$ in our group $G$, if `a*b=a*c` then `b=c`. \n\nBut before we can do that, we have to import our group and talk about what tools we have to start. So here is our first Lean code.\n\n\n-/\n\nimport algebra.group \nvariables {G : Type*} [group G] \n\n\n/- \nThe first line imports code that other people have written. Specifically, the code defines a group. \nIt defines a group with the following three axioms: associativity, an identity, and inverse. In Lean this looks like \n-/\n\n#check (mul_assoc : \u2200 a b c : G, a * b * c = a * (b * c))\n#check (one_mul : \u2200 a : G, 1 * a = a)\n#check (mul_left_inv : \u2200 a : G, a\u207b\u00b9 * a = 1)\n\nnamespace my_group \n\n/- \nThe second line defines the type of $G$ as a group: in essence, telling lean that $G$ is a group. \n-/\n\n/- Lemma\nFor $a$, $b$, and $c$, in a group $G$, if `a*b=a*c` then `b=c`. \n-/\ntheorem mul_left_cancel(a b c : G)(h1: a*b=a*c): b=c :=\nbegin\n", "proof": "    rw \u2190 one_mul b,\n    rw \u2190 mul_left_inv a,\n    rw mul_assoc, \n    rw h1, \n    rw \u2190 mul_assoc,\n    rw mul_left_inv,\n    rw one_mul,", "textAfter": "\nend\nend my_group ", "height": 7, "editorText": "sorry", "lineOffset": 37, "name": "mul_left_cancel", "statement": "(a b c : G)(h1: a*b=a*c): b=c"}, {"type": "lean", "content": "9", "hidden": false}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "text", "content": "10"}, {"type": "lean", "content": "11", "hidden": true}, {"type": "lean", "content": "12", "hidden": true}, {"type": "lean", "content": "13", "hidden": true}, {"type": "lemma", "text": "14", "lean": "theorem mul_one (a : G) : a * 1 = a :=\n", "sideBar": true, "firstProofLineNumber": 29, "lastProofLineNumber": 32, "textBefore": "/-\n# Using Apply to Prove Right Identity Multiplication.\n\n\nIn Lean, proving left cancellation is a very powerful result.\n\nThis is because it allows us to left multiply an equation by any element of the group.\n\nWe do this using the code `apply`. For example, we will try to prove that `a*1=a` for all `a` in `G`. \n\nRemember, we don't know this yet, since our axiom only tells us that `1*a=a` for all `a` in `G`, but nothing about right hand side multiplication.#check\n\nI've given you the first line, which is `apply mul_left_cancel a\u207b\u00b9`, which multiplies both sides of `b=c` by `a\u207b\u00b9`. You can write `a\u207b\u00b9` by writing `a\\inv`.\n\nAgain, if you get stuck, the solution is below. Remember, the only tools we have right now are `rw`, our axioms, and `mul_left_cancel`.\n\n-/\n\nimport algebra.group  -- hide\nvariables {G : Type*} [group G] --hide \n\nnamespace my_group  --hide\n\n/- Lemma\nFor $a$, $b$, and $c$, in a group $G$, if `a*b=a*c` then `b=c`. \n-/\ntheorem mul_one (a : G) : a * 1 = a :=\nbegin\n", "proof": "    apply mul_left_cancel a\u207b\u00b9,\n    rw \u2190 mul_assoc,\n    rw mul_left_inv,\n    rw one_mul,", "textAfter": "\nend\nend my_group --hide\n\n/-\n<details>\n  <summary>Solution Line 1</summary>\n        `rw \u2190 mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `rw mul_left_inv,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `rw one_mul,`\n</details>\n-/", "height": 4, "editorText": "sorry", "lineOffset": 28, "name": "mul_one", "statement": "(a : G) : a * 1 = a"}, {"type": "lean", "content": "15", "hidden": true}, {"type": "text", "content": "16"}]}]}], "texts": [["Learning Lean Through Introductory Group Theory", "# Learning Lean Through Introductory Group Theory, version 1.0.4.\n\n## By Adam Dionne\n\nOur goal today is to learn about Lean, a proof assistant programming language. To do so, we will be studying group theory.\n\nTo begin, click on the first level, \"Group Properties\", on the right hand side of the screen.\n\n# Credits\n\nThis website was constructed by the open source Lean Game Maker, found <a href=\"https://github.com/mpedramfar/Lean-game-maker\" target=\"blank\">here</a>.\n\n", "Group Properties", "# Proving left cancellation.\n\n\nOur first goal is to prove that we have left cancellation in a group. \n\nMore precisely, given elements $a$, $b$, and $c$ in our group $G$, if `a*b=a*c` then `b=c`. \n\nBut before we can do that, we have to import our group and talk about what tools we have to start. So here is our first Lean code.\n\n\n", "import algebra.group \nvariables {G : Type*} [group G] \n", "The first line imports code that other people have written. Specifically, the code defines a group. \nIt defines a group with the following three axioms: associativity, an identity, and inverse. In Lean this looks like \n", "#check (mul_assoc : \u2200 a b c : G, a * b * c = a * (b * c))\n#check (one_mul : \u2200 a : G, 1 * a = a)\n#check (mul_left_inv : \u2200 a : G, a\u207b\u00b9 * a = 1)\nnamespace my_group \n", "The second line defines the type of $G$ as a group: in essence, telling lean that $G$ is a group. \n", "For $a$, $b$, and $c$, in a group $G$, if `a*b=a*c` then `b=c`. \n", "end my_group ", "# Using Apply to Prove Right Identity Multiplication.\n\n\nIn Lean, proving left cancellation is a very powerful result.\n\nThis is because it allows us to left multiply an equation by any element of the group.\n\nWe do this using the code `apply`. For example, we will try to prove that `a*1=a` for all `a` in `G`. \n\nRemember, we don't know this yet, since our axiom only tells us that `1*a=a` for all `a` in `G`, but nothing about right hand side multiplication.#check\n\nI've given you the first line, which is `apply mul_left_cancel a\u207b\u00b9`, which multiplies both sides of `b=c` by `a\u207b\u00b9`. You can write `a\u207b\u00b9` by writing `a\\inv`.\n\nAgain, if you get stuck, the solution is below. Remember, the only tools we have right now are `rw`, our axioms, and `mul_left_cancel`.\n\n", "import algebra.group  -- hide\n", "variables {G : Type*} [group G] --hide \n", "namespace my_group  --hide\n", "For $a$, $b$, and $c$, in a group $G$, if `a*b=a*c` then `b=c`. \n", "end my_group --hide\n", "<details>\n  <summary>Solution Line 1</summary>\n        `rw \u2190 mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `rw mul_left_inv,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `rw one_mul,`\n</details>\n"]]}