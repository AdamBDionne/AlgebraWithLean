{"name": "Learning Lean Through Introductory Group Theory", "version": "1.0.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Learning Lean Through Introductory Group Theory-1.0.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 9, "objects": [{"type": "text", "content": "3"}, {"type": "lean", "content": "4", "hidden": false}, {"type": "lean", "content": "5", "hidden": true}, {"type": "lean", "content": "6", "hidden": false}, {"type": "lean", "content": "7", "hidden": true}, {"type": "axiom", "content": "8", "name": "mul_assoc : \u2200 a b c : G, a * b * c = a * (b * c)", "sideBar": true}, {"type": "axiom", "content": "9", "name": "one_mul : \u2200 a : G, 1 * a = a", "sideBar": true}, {"type": "axiom", "content": "10", "name": "mul_left_inv : \u2200 a : G, a\u207b\u00b9 * a = 1", "sideBar": true}, {"type": "text", "content": "11"}, {"type": "lemma", "text": "12", "lean": "theorem mul_left_cancel(a b c : G)(h1: a*b=a*c): b=c :=\n", "sideBar": true, "firstProofLineNumber": 55, "lastProofLineNumber": 62, "textBefore": "/-\n# Proving left cancellation.\n\n\nOur first goal is to prove that we have left cancellation in a group. \n\nMore precisely, given elements `a`, `b`, and `c` in our group $G$, if `a*b=a*c` then `b=c`. \n\nBut before we can do that, we need to know what axioms we are starting with. Lean defines a group as having associativity, an identity, and an inverse.\n\nIn particular, you can see the these properties written in Lean below. \n\n-/\n\n\nimport algebra.group \nvariables {G : Type*} [group G] -- hide\n\n#check (mul_assoc : \u2200 a b c : G, a * b * c = a * (b * c))\n#check (one_mul : \u2200 a : G, 1 * a = a)\n#check (mul_left_inv : \u2200 a : G, a\u207b\u00b9 * a = 1)\n\nnamespace my_group -- hide\n\n\n/- Axiom: mul_assoc : \u2200 a b c : G, a * b * c = a * (b * c)\n-/\n\n/- Axiom: one_mul : \u2200 a : G, 1 * a = a\n-/\n\n/- Axiom: mul_left_inv : \u2200 a : G, a\u207b\u00b9 * a = 1\n-/\n\n/- \nThe `#check` means we are asking Lean to check if these are true for our group `G`. And thankfully they are! \n\nWe will prove our first lemma, left cancellation, using these properties along with a single tactic: `rw`. \n\nThis tactic stands for rewrite. For example, if we had a hypothesis `h` that states `X=Y`, then `rw h,` would rewrite every `X` in our goal to a `Y`.\n\nFor example, I recommend the first line `rw \u2190 one_mul b,` which rewrites the goal `b=c` by replacing the `b` with `1*b`.\n\nThe left arrow symbol, `\u2190`, which you can get by writing `\\l`, reads the hypothesis in reverse. For example, `one_mul` says that `1*b=b` but we wanted to replace `b` with `1*b`, so we needed a `\u2190`.\n\nWhile proving this, keep in mind what hypotheses we currently have. From our group axioms, we have `mul_assoc, one_mul,` and `mul_left_inv`. And finally, from our theorem we have our hypothesis `h1 : a*b = a*c`.\n\n-/\n\n/- Lemma\nFor $a$, $b$, and $c$, in a group $G$, if `a*b=a*c` then `b=c`. \n-/\ntheorem mul_left_cancel(a b c : G)(h1: a*b=a*c): b=c :=\nbegin\n", "proof": "    rw \u2190 one_mul b,\n    rw \u2190 mul_left_inv a,\n    rw mul_assoc, \n    rw h1, \n    rw \u2190 mul_assoc,\n    rw mul_left_inv,\n    rw one_mul,\n    ", "textAfter": "\nend\nend my_group --hide\n/- Tactic : rw\nThe code `rw` rewrites our goal using a hypothesis `h`. For example, if our goal is `b=c` and we have the hypothesis `h: b=a`, then `rw h,` will get you `a=c`.\n\nRemember you can use `\u2190` to swith the order of the hypothesis. \n-/\n\n/-\n## Solution\nHere you can reveal the solution to this level, one line at a time. If stuck, I encourage you to only reveal upto the point you were stuck, and then try from there!\n\nFor this first level, I recommend liberal use of this solution! \n<details>\n  <summary>Solution Line 1</summary>\n        `rw \u2190 one_mul b,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `rw \u2190 mul_left_inv a,`\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `rw mul_assoc, `\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw h1,`\n</details>\n<details>\n  <summary>Solution Line 5</summary>\n        `rw \u2190 mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 6</summary>\n        `rw mul_left_inv,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `rw one_mul,`\n</details>\n-/\n", "height": 8, "editorText": "sorry", "lineOffset": 54, "name": "mul_left_cancel", "statement": "(a b c : G)(h1: a*b=a*c): b=c"}, {"type": "lean", "content": "13", "hidden": true}, {"type": "tactic", "content": "14", "name": "rw", "sideBar": true}, {"type": "text", "content": "15"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "text", "content": "16"}, {"type": "lean", "content": "17", "hidden": true}, {"type": "lean", "content": "18", "hidden": true}, {"type": "lean", "content": "19", "hidden": true}, {"type": "lean", "content": "20", "hidden": true}, {"type": "lemma", "text": "21", "lean": "lemma mul_one (a : G) : a * 1 = a :=\n", "sideBar": true, "firstProofLineNumber": 32, "lastProofLineNumber": 36, "textBefore": "/-\n# Using Apply to Prove Right Identity Multiplication.\n\n\nIn Lean, proving left cancellation is a very powerful result.\n\nThis is because it allows us to left multiply an equation by any element of the group.\n\nWe do this using the code `apply`. For example, if we have `a=b` then `apply mul_left_cancel c` will left multiply by `c`.\n\nTo demonstrate this, we will try to prove that `a*1=a` for all `a` in `G`. \n\nRemember, we don't know this yet, since our axiom only tells us that `1*a=a` for all `a` in `G`, but nothing about right hand side multiplication.\n\nFor the first line of code, I suggest `apply mul_left_cancel a\u207b\u00b9`, which multiplies both sides of `b=c` by `a\u207b\u00b9`. You can write `a\u207b\u00b9` by writing `a\\inv`.\n\nAgain, if you get stuck, the solution is below. Remember, the only tools we have right now are `rw`, `apply`, our axioms, and `mul_left_cancel`.\n\n-/\n\nimport algebra.group  -- hide\nimport levels.group_props.left_cancel --hide\nvariables {G : Type*} [group G] --hide \n\nnamespace my_group  --hide\n\n/- Lemma\nFor $a$ in a group $G$, `a*1=a`. \n-/\nlemma mul_one (a : G) : a * 1 = a :=\nbegin\n", "proof": "    apply mul_left_cancel a\u207b\u00b9,\n    rw \u2190 mul_assoc,\n    rw mul_left_inv,\n    rw one_mul,\n    ", "textAfter": "\nend\nend my_group --hide\n\n/- Tactic : apply\nThe code `apply` lets us apply a theorem. For example, we have left cancellation: `a*b=a*c` implies `b=c`. So if we have `d=e` we can apply left cancellation in reverse and write `f*d=f*e` for any `f`.\n\nWe do this by `apply mul_left_cancel f,`.\n-/\n\n/-\n## Solution\n<details>\n  <summary>Solution Line 1</summary>\n        `apply mul_left_cancel a\u207b\u00b9,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `rw \u2190 mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `rw mul_left_inv,`\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw one_mul,`\n</details>\n-/", "height": 5, "editorText": "sorry", "lineOffset": 31, "name": "mul_one", "statement": "(a : G) : a * 1 = a"}, {"type": "lean", "content": "22", "hidden": true}, {"type": "tactic", "content": "23", "name": "apply", "sideBar": true}, {"type": "text", "content": "24"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "text", "content": "25"}, {"type": "lean", "content": "26", "hidden": true}, {"type": "lean", "content": "27", "hidden": true}, {"type": "lean", "content": "28", "hidden": true}, {"type": "lean", "content": "29", "hidden": true}, {"type": "lemma", "text": "30", "lean": "lemma mul_right_inv (a : G) : a * a\u207b\u00b9 = 1 :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 25, "textBefore": "/-\n# Proving Right Inverses\n\nNow we move onto proving that we have inverses on the right as expected. We can do this with the same ideas as our last proof.\n\nIf you get stuck, make sure to check out the left hand side for tactics and theorems we've encountered. \n\n-/\n\nimport algebra.group  -- hide\nimport levels.group_props.level2 --hide\nvariables {G : Type*} [group G] --hide \n\nnamespace my_group  --hide\n\n/- Lemma\nFor `a` in `G`, `a*a\u207b\u00b9=1`. \n-/\nlemma mul_right_inv (a : G) : a * a\u207b\u00b9 = 1 :=\nbegin\n", "proof": "    apply mul_left_cancel a\u207b\u00b9,\n    rw \u2190 mul_assoc,\n    rw mul_left_inv, \n    rw one_mul,\n    rw mul_one,", "textAfter": "\nend\nend my_group --hide\n\n/-\n## Solution\n<details>\n  <summary>Solution Line 1</summary>\n        `apply mul_left_cancel a\u207b\u00b9,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `rw \u2190 mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `rw mul_left_inv,`\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw one_mul,`\n</details>\n<details>\n  <summary>Solution Line 5</summary>\n        `rw mul_one,`\n</details>\n-/", "height": 5, "editorText": "sorry", "lineOffset": 20, "name": "mul_right_inv", "statement": "(a : G) : a * a\u207b\u00b9 = 1"}, {"type": "lean", "content": "31", "hidden": true}, {"type": "text", "content": "32"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "text", "content": "33"}, {"type": "lean", "content": "34", "hidden": true}, {"type": "lean", "content": "35", "hidden": true}, {"type": "lean", "content": "36", "hidden": true}, {"type": "lean", "content": "37", "hidden": true}, {"type": "lemma", "text": "38", "lean": "lemma mul_right_cancel(a b c : G)(h1: b*a=c*a): b=c :=\n", "sideBar": true, "firstProofLineNumber": 23, "lastProofLineNumber": 29, "textBefore": "/-\n# Proving Right Cancellation\n\nNow that we've proven inverses and the identity on the right, we can prove right cancellation. This uses the same ideas as proving left cancellation, except we do things on the right.\n\nOnce we prove this, we can both left and right multiply group equations!\n\nThis is the final boss of the world, so good luck! \n\n-/\n\nimport algebra.group  -- hide\nimport levels.group_props.level3 --hide\nvariables {G : Type*} [group G] --hide \n\nnamespace my_group  --hide\n\n/- Lemma\nFor `a`, `b`, and `c` in `G`, if `b*a=c*a` then `b=c`. \n-/\nlemma mul_right_cancel(a b c : G)(h1: b*a=c*a): b=c :=\nbegin\n", "proof": "   rw \u2190 mul_one b,\n   rw \u2190 mul_right_inv a, \n   rw \u2190 mul_assoc,\n   rw h1,\n   rw mul_assoc, \n   rw mul_right_inv,\n   rw mul_one,", "textAfter": "\nend\nend my_group --hide\n\n/-\n## Solution\n<details>\n  <summary>Solution Line 1</summary>\n        `rw \u2190 mul_one b,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `rw \u2190 mul_right_inv a, `\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `rw \u2190 mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw h1,`\n</details>\n<details>\n  <summary>Solution Line 5</summary>\n        `rw mul_assoc, `\n</details>\n<details>\n  <summary>Solution Line 6</summary>\n        `rw mul_right_inv,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `rw mul_one,`\n</details>\n-/", "height": 7, "editorText": "sorry", "lineOffset": 22, "name": "mul_right_cancel", "statement": "(a b c : G)(h1: b*a=c*a): b=c"}, {"type": "lean", "content": "39", "hidden": true}, {"type": "text", "content": "40"}]}]}, {"name": "41", "levels": [{"name": "", "problemIndex": 5, "objects": [{"type": "text", "content": "42"}, {"type": "lean", "content": "43", "hidden": true}, {"type": "lean", "content": "44", "hidden": true}, {"type": "lean", "content": "45", "hidden": true}, {"type": "lean", "content": "46", "hidden": true}, {"type": "lemma", "text": "47", "lean": "lemma unique_identity {a b : G} : a * b = b \u2194 a = 1 :=\n", "sideBar": true, "firstProofLineNumber": 29, "lastProofLineNumber": 36, "textBefore": "/-\n# Proving If and Only If Statements\n\nNow that we've proven some basic group properties, we look to prove some different types of theorems. \n\nAs the title alludes to, we look to prove if and only if statements. For example, in a group we know that the identity is unique.\n\nSo we want to prove that *a*b=b* if and only if *a=1*. We write this as we write most lemmas, but now use the `\u2194` symbol which you can get by typing `\\iff`.\n\nThen, to prove the seperate cases we start with the code `split,`. This allows us to prove one case at a time. \n\nAfter this, we can use `intro h`, which gives us a specific hypothesis `h` to represent our condition. \n\nFor example, our first case will be `a*b = b \u2192 a =1`. So `intro h,` will give us the hypothesis `h: a*b=b`.\n\n-/\n\nimport algebra.group  -- hide\nimport levels.group_props.level4 --hide\nvariables {G : Type*} [group G] --hide \n\nnamespace my_group  --hide\n\n/- Lemma\nFor a group `G`, `a*b=b` if and only if `a=1`. \n-/\nlemma unique_identity {a b : G} : a * b = b \u2194 a = 1 :=\nbegin\n", "proof": "    split,\n    intro h,\n    apply mul_right_cancel b,\n    rw one_mul,\n    rw h,\n    intro h,\n    rw h,\n    rw one_mul,", "textAfter": "\nend\nend my_group --hide\n\n/- Tactic : split\nThe code `split,` splits an if and only if statement into two separate goals you have to prove. \n\n-/\n/- Tactic : intro\nThe code `intro` gives you a specific hypothesis of a general condition.\n\nFor example, if we have that ` b*a=a*b \u2192 a=c` then `intro h,` will give us `h: b*a=a*b`.\n-/\n\n\n/-\n## Solution\n<details>\n  <summary>Solution Line 1</summary>\n        ` split,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `intro h,`\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `apply mul_right_cancel b,`\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw one_mul,`\n</details>\n<details>\n  <summary>Solution Line 5</summary>\n        `rw h,`\n</details>\n<details>\n  <summary>Solution Line 6</summary>\n        `intro h,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `rw h,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `rw one_mul,`\n</details>\n-/", "height": 8, "editorText": "sorry", "lineOffset": 28, "name": "unique_identity", "statement": "{a b : G} : a * b = b \u2194 a = 1"}, {"type": "lean", "content": "48", "hidden": true}, {"type": "tactic", "content": "49", "name": "split", "sideBar": true}, {"type": "tactic", "content": "50", "name": "intro", "sideBar": true}, {"type": "text", "content": "51"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "text", "content": "52"}, {"type": "lean", "content": "53", "hidden": true}, {"type": "lean", "content": "54", "hidden": true}, {"type": "lean", "content": "55", "hidden": true}, {"type": "lean", "content": "56", "hidden": true}, {"type": "lemma", "text": "57", "lean": "lemma unique_inverse {a b : G}: a*b = 1 \u2194 b = a\u207b\u00b9 :=\n", "sideBar": true, "firstProofLineNumber": 20, "lastProofLineNumber": 27, "textBefore": "/-\n# Proving Uniqueness of Inverses\n\nNow we look to prove another if and only if statement: the corresponding one for inverses. \n\nThis proof is done very similarly to the last one, so feel free to refer back to it. \n-/\n\nimport algebra.group  -- hide\nimport levels.iff.level1 --hide\nvariables {G : Type*} [group G] --hide \n\nnamespace my_group  --hide\n\n/- Lemma\nFor a group `G`, `a*b=1` if and only if `b=a\u207b\u00b9`. \n-/\nlemma unique_inverse {a b : G}: a*b = 1 \u2194 b = a\u207b\u00b9 :=\nbegin\n", "proof": "    split,\n    intro h,\n    apply mul_left_cancel a,\n    rw h,\n    rw mul_right_inv,\n    intro h,\n    rw h,\n    rw mul_right_inv,", "textAfter": "\nend\nend my_group --hide\n\n/-\n## Solution\n<details>\n  <summary>Solution Line 1</summary>\n        `split,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `intro h,`\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `apply mul_left_cancel a,`\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw h,`\n</details>\n<details>\n  <summary>Solution Line 5</summary>\n        ` rw mul_right_inv,`\n</details>\n<details>\n  <summary>Solution Line 6</summary>\n        `intro h,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `rw h,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `rw mul_right_inv,`\n</details>\n-/", "height": 8, "editorText": "sorry", "lineOffset": 19, "name": "unique_inverse", "statement": "{a b : G}: a*b = 1 \u2194 b = a\u207b\u00b9"}, {"type": "lean", "content": "58", "hidden": true}, {"type": "text", "content": "59"}]}], "parents": [0]}, {"name": "60", "levels": [{"name": "", "problemIndex": 5, "objects": [{"type": "text", "content": "61"}, {"type": "lean", "content": "62", "hidden": true}, {"type": "lean", "content": "63", "hidden": true}, {"type": "lean", "content": "64", "hidden": true}, {"type": "lean", "content": "65", "hidden": true}, {"type": "lemma", "text": "66", "lean": "lemma problem1 (a b :G)(h: (a*b)*(a*b)=a*a*b*b): b*a=a*b :=\n", "sideBar": true, "firstProofLineNumber": 25, "lastProofLineNumber": 32, "textBefore": "/-\n# Solving Problems\n\nHaving proven same basic group properties, we can solve some problems! I went and looked at my old Abstract Algebra textbook - A First Course in Abstract Algebra by John B. Fraleigh - and found two problems suitable for us to solve.#check\n\nBesides the tactics we've discussed in the previous world, there is one thing that can be helpful.\n\nThe code `simp [theorem]` tries to simplify the goal using the theorem. This is especially helpful for something like `mul_assoc`, which can be tricky when operating on many elements. \n\nSo `simp [mul_assoc]` is recommended. \n\n-/\n\nimport algebra.group  -- hide\nimport levels.group_props.level4 --hide\nvariables {G : Type*} [group G] --hide \n\nnamespace my_group  --hide\n\n/- Lemma\nFor a group `G`, if `(a*b)*(a*b)=a*a*b*b` then `b*a=a*b`. \n-/\nlemma problem1 (a b :G)(h: (a*b)*(a*b)=a*a*b*b): b*a=a*b :=\nbegin\n", "proof": "    apply mul_right_cancel b,\n    apply mul_left_cancel a,\n    rw \u2190  mul_assoc,\n    rw \u2190 mul_assoc,\n    rw \u2190 mul_assoc, \n    rw \u2190 mul_assoc,\n    rw \u2190 h,\n    simp [mul_assoc],", "textAfter": "\nend\nend my_group --hide\n\n/- Tactic : simp\nThe code `simp,` tries to known theorems to simplify the goal. \n-/\n\n\n\n/-\n## Solution\n<details>\n  <summary>Solution Line 1</summary>\n        `apply mul_right_cancel b,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `apply mul_left_cancel a,`\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `rw \u2190  mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw \u2190  mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 5</summary>\n        `rw \u2190  mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 6</summary>\n        `rw \u2190 h,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `simp [mul_assoc],`\n</details>\n-/", "height": 8, "editorText": "sorry", "lineOffset": 24, "name": "problem1", "statement": "(a b :G)(h: (a*b)*(a*b)=a*a*b*b): b*a=a*b"}, {"type": "lean", "content": "67", "hidden": true}, {"type": "tactic", "content": "68", "name": "simp", "sideBar": true}, {"type": "text", "content": "69"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "text", "content": "70"}, {"type": "lean", "content": "71", "hidden": true}, {"type": "lean", "content": "72", "hidden": true}, {"type": "lean", "content": "73", "hidden": true}, {"type": "lean", "content": "74", "hidden": true}, {"type": "lemma", "text": "75", "lean": "lemma problem1 (a b :G)(h: (a*b)*(a*b)=a*a*b*b): b*a=a*b :=\n", "sideBar": true, "firstProofLineNumber": 25, "lastProofLineNumber": 32, "textBefore": "/-\n# Solving Problems\n\nHaving proven same basic group properties, we can solve some problems! I went and looked at my old Abstract Algebra textbook - A First Course in Abstract Algebra by John B. Fraleigh - and found two problems suitable for us to solve.#check\n\nBesides the tactics we've discussed in the previous world, there is one thing that can be helpful.\n\nThe code `simp [theorem]` tries to simplify the goal using the theorem. This is especially helpful for something like `mul_assoc`, which can be tricky when operating on many elements. \n\nSo `simp [mul_assoc]` is recommended. \n\n-/\n\nimport algebra.group  -- hide\nimport levels.group_props.level4 --hide\nvariables {G : Type*} [group G] --hide \n\nnamespace my_group  --hide\n\n/- Lemma\nFor a group `G`, if `(a*b)*(a*b)=a*a*b*b` then `b*a=a*b`. \n-/\nlemma problem1 (a b :G)(h: (a*b)*(a*b)=a*a*b*b): b*a=a*b :=\nbegin\n", "proof": "    apply mul_right_cancel b,\n    apply mul_left_cancel a,\n    rw \u2190  mul_assoc,\n    rw \u2190 mul_assoc,\n    rw \u2190 mul_assoc, \n    rw \u2190 mul_assoc,\n    rw \u2190 h,\n    simp [mul_assoc],", "textAfter": "\nend\nend my_group --hide\n\n/- Tactic : simp\nThe code `simp,` tries to known theorems to simplify the goal. \n-/\n\n\n\n/-\n## Solution\n<details>\n  <summary>Solution Line 1</summary>\n        ` split,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `intro h,`\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `apply mul_right_cancel b,`\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw one_mul,`\n</details>\n<details>\n  <summary>Solution Line 5</summary>\n        `rw h,`\n</details>\n<details>\n  <summary>Solution Line 6</summary>\n        `intro h,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `rw h,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `rw one_mul,`\n</details>\n-/", "height": 8, "editorText": "sorry", "lineOffset": 24, "name": "problem1", "statement": "(a b :G)(h: (a*b)*(a*b)=a*a*b*b): b*a=a*b"}, {"type": "lean", "content": "76", "hidden": true}, {"type": "tactic", "content": "77", "name": "simp", "sideBar": true}, {"type": "text", "content": "78"}]}], "parents": [0]}], "texts": [["Learning Lean Through Introductory Group Theory", "# Learning Lean Through Introductory Group Theory, version 1.0.4.\n\n## By Adam Dionne\n\nOur goal today is to learn about Lean, a proof assistant programming language. To do so, we will be studying group theory.\n\nTo begin, click on the first level, \"Group Properties\", on the right hand side of the screen.\n\n# Credits\n\nThis website was constructed by the open source Lean Game Maker, found <a href=\"https://github.com/mpedramfar/Lean-game-maker\" target=\"blank\">here</a>.\n\n", "Group Properties", "# Proving left cancellation.\n\n\nOur first goal is to prove that we have left cancellation in a group. \n\nMore precisely, given elements `a`, `b`, and `c` in our group $G$, if `a*b=a*c` then `b=c`. \n\nBut before we can do that, we need to know what axioms we are starting with. Lean defines a group as having associativity, an identity, and an inverse.\n\nIn particular, you can see the these properties written in Lean below. \n\n", "import algebra.group \n", "variables {G : Type*} [group G] -- hide\n", "#check (mul_assoc : \u2200 a b c : G, a * b * c = a * (b * c))\n#check (one_mul : \u2200 a : G, 1 * a = a)\n#check (mul_left_inv : \u2200 a : G, a\u207b\u00b9 * a = 1)\n", "namespace my_group -- hide\n", "", "", "", "The `#check` means we are asking Lean to check if these are true for our group `G`. And thankfully they are! \n\nWe will prove our first lemma, left cancellation, using these properties along with a single tactic: `rw`. \n\nThis tactic stands for rewrite. For example, if we had a hypothesis `h` that states `X=Y`, then `rw h,` would rewrite every `X` in our goal to a `Y`.\n\nFor example, I recommend the first line `rw \u2190 one_mul b,` which rewrites the goal `b=c` by replacing the `b` with `1*b`.\n\nThe left arrow symbol, `\u2190`, which you can get by writing `\\l`, reads the hypothesis in reverse. For example, `one_mul` says that `1*b=b` but we wanted to replace `b` with `1*b`, so we needed a `\u2190`.\n\nWhile proving this, keep in mind what hypotheses we currently have. From our group axioms, we have `mul_assoc, one_mul,` and `mul_left_inv`. And finally, from our theorem we have our hypothesis `h1 : a*b = a*c`.\n\n", "For $a$, $b$, and $c$, in a group $G$, if `a*b=a*c` then `b=c`. \n", "end my_group --hide\n", "The code `rw` rewrites our goal using a hypothesis `h`. For example, if our goal is `b=c` and we have the hypothesis `h: b=a`, then `rw h,` will get you `a=c`.\n\nRemember you can use `\u2190` to swith the order of the hypothesis. \n", "## Solution\nHere you can reveal the solution to this level, one line at a time. If stuck, I encourage you to only reveal upto the point you were stuck, and then try from there!\n\nFor this first level, I recommend liberal use of this solution! \n<details>\n  <summary>Solution Line 1</summary>\n        `rw \u2190 one_mul b,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `rw \u2190 mul_left_inv a,`\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `rw mul_assoc, `\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw h1,`\n</details>\n<details>\n  <summary>Solution Line 5</summary>\n        `rw \u2190 mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 6</summary>\n        `rw mul_left_inv,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `rw one_mul,`\n</details>\n", "# Using Apply to Prove Right Identity Multiplication.\n\n\nIn Lean, proving left cancellation is a very powerful result.\n\nThis is because it allows us to left multiply an equation by any element of the group.\n\nWe do this using the code `apply`. For example, if we have `a=b` then `apply mul_left_cancel c` will left multiply by `c`.\n\nTo demonstrate this, we will try to prove that `a*1=a` for all `a` in `G`. \n\nRemember, we don't know this yet, since our axiom only tells us that `1*a=a` for all `a` in `G`, but nothing about right hand side multiplication.\n\nFor the first line of code, I suggest `apply mul_left_cancel a\u207b\u00b9`, which multiplies both sides of `b=c` by `a\u207b\u00b9`. You can write `a\u207b\u00b9` by writing `a\\inv`.\n\nAgain, if you get stuck, the solution is below. Remember, the only tools we have right now are `rw`, `apply`, our axioms, and `mul_left_cancel`.\n\n", "import algebra.group  -- hide\n", "import levels.group_props.left_cancel --hide\n", "variables {G : Type*} [group G] --hide \n", "namespace my_group  --hide\n", "For $a$ in a group $G$, `a*1=a`. \n", "end my_group --hide\n", "The code `apply` lets us apply a theorem. For example, we have left cancellation: `a*b=a*c` implies `b=c`. So if we have `d=e` we can apply left cancellation in reverse and write `f*d=f*e` for any `f`.\n\nWe do this by `apply mul_left_cancel f,`.\n", "## Solution\n<details>\n  <summary>Solution Line 1</summary>\n        `apply mul_left_cancel a\u207b\u00b9,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `rw \u2190 mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `rw mul_left_inv,`\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw one_mul,`\n</details>\n", "# Proving Right Inverses\n\nNow we move onto proving that we have inverses on the right as expected. We can do this with the same ideas as our last proof.\n\nIf you get stuck, make sure to check out the left hand side for tactics and theorems we've encountered. \n\n", "import algebra.group  -- hide\n", "import levels.group_props.level2 --hide\n", "variables {G : Type*} [group G] --hide \n", "namespace my_group  --hide\n", "For `a` in `G`, `a*a\u207b\u00b9=1`. \n", "end my_group --hide\n", "## Solution\n<details>\n  <summary>Solution Line 1</summary>\n        `apply mul_left_cancel a\u207b\u00b9,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `rw \u2190 mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `rw mul_left_inv,`\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw one_mul,`\n</details>\n<details>\n  <summary>Solution Line 5</summary>\n        `rw mul_one,`\n</details>\n", "# Proving Right Cancellation\n\nNow that we've proven inverses and the identity on the right, we can prove right cancellation. This uses the same ideas as proving left cancellation, except we do things on the right.\n\nOnce we prove this, we can both left and right multiply group equations!\n\nThis is the final boss of the world, so good luck! \n\n", "import algebra.group  -- hide\n", "import levels.group_props.level3 --hide\n", "variables {G : Type*} [group G] --hide \n", "namespace my_group  --hide\n", "For `a`, `b`, and `c` in `G`, if `b*a=c*a` then `b=c`. \n", "end my_group --hide\n", "## Solution\n<details>\n  <summary>Solution Line 1</summary>\n        `rw \u2190 mul_one b,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `rw \u2190 mul_right_inv a, `\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `rw \u2190 mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw h1,`\n</details>\n<details>\n  <summary>Solution Line 5</summary>\n        `rw mul_assoc, `\n</details>\n<details>\n  <summary>Solution Line 6</summary>\n        `rw mul_right_inv,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `rw mul_one,`\n</details>\n", "If and Only If", "# Proving If and Only If Statements\n\nNow that we've proven some basic group properties, we look to prove some different types of theorems. \n\nAs the title alludes to, we look to prove if and only if statements. For example, in a group we know that the identity is unique.\n\nSo we want to prove that *a*b=b* if and only if *a=1*. We write this as we write most lemmas, but now use the `\u2194` symbol which you can get by typing `\\iff`.\n\nThen, to prove the seperate cases we start with the code `split,`. This allows us to prove one case at a time. \n\nAfter this, we can use `intro h`, which gives us a specific hypothesis `h` to represent our condition. \n\nFor example, our first case will be `a*b = b \u2192 a =1`. So `intro h,` will give us the hypothesis `h: a*b=b`.\n\n", "import algebra.group  -- hide\n", "import levels.group_props.level4 --hide\n", "variables {G : Type*} [group G] --hide \n", "namespace my_group  --hide\n", "For a group `G`, `a*b=b` if and only if `a=1`. \n", "end my_group --hide\n", "The code `split,` splits an if and only if statement into two separate goals you have to prove. \n\n", "The code `intro` gives you a specific hypothesis of a general condition.\n\nFor example, if we have that ` b*a=a*b \u2192 a=c` then `intro h,` will give us `h: b*a=a*b`.\n", "## Solution\n<details>\n  <summary>Solution Line 1</summary>\n        ` split,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `intro h,`\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `apply mul_right_cancel b,`\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw one_mul,`\n</details>\n<details>\n  <summary>Solution Line 5</summary>\n        `rw h,`\n</details>\n<details>\n  <summary>Solution Line 6</summary>\n        `intro h,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `rw h,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `rw one_mul,`\n</details>\n", "# Proving Uniqueness of Inverses\n\nNow we look to prove another if and only if statement: the corresponding one for inverses. \n\nThis proof is done very similarly to the last one, so feel free to refer back to it. \n", "import algebra.group  -- hide\n", "import levels.iff.level1 --hide\n", "variables {G : Type*} [group G] --hide \n", "namespace my_group  --hide\n", "For a group `G`, `a*b=1` if and only if `b=a\u207b\u00b9`. \n", "end my_group --hide\n", "## Solution\n<details>\n  <summary>Solution Line 1</summary>\n        `split,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `intro h,`\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `apply mul_left_cancel a,`\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw h,`\n</details>\n<details>\n  <summary>Solution Line 5</summary>\n        ` rw mul_right_inv,`\n</details>\n<details>\n  <summary>Solution Line 6</summary>\n        `intro h,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `rw h,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `rw mul_right_inv,`\n</details>\n", "Problems", "# Solving Problems\n\nHaving proven same basic group properties, we can solve some problems! I went and looked at my old Abstract Algebra textbook - A First Course in Abstract Algebra by John B. Fraleigh - and found two problems suitable for us to solve.#check\n\nBesides the tactics we've discussed in the previous world, there is one thing that can be helpful.\n\nThe code `simp [theorem]` tries to simplify the goal using the theorem. This is especially helpful for something like `mul_assoc`, which can be tricky when operating on many elements. \n\nSo `simp [mul_assoc]` is recommended. \n\n", "import algebra.group  -- hide\n", "import levels.group_props.level4 --hide\n", "variables {G : Type*} [group G] --hide \n", "namespace my_group  --hide\n", "For a group `G`, if `(a*b)*(a*b)=a*a*b*b` then `b*a=a*b`. \n", "end my_group --hide\n", "The code `simp,` tries to known theorems to simplify the goal. \n", "## Solution\n<details>\n  <summary>Solution Line 1</summary>\n        `apply mul_right_cancel b,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `apply mul_left_cancel a,`\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `rw \u2190  mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw \u2190  mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 5</summary>\n        `rw \u2190  mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 6</summary>\n        `rw \u2190 h,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `simp [mul_assoc],`\n</details>\n", "# Solving Problems\n\nHaving proven same basic group properties, we can solve some problems! I went and looked at my old Abstract Algebra textbook - A First Course in Abstract Algebra by John B. Fraleigh - and found two problems suitable for us to solve.#check\n\nBesides the tactics we've discussed in the previous world, there is one thing that can be helpful.\n\nThe code `simp [theorem]` tries to simplify the goal using the theorem. This is especially helpful for something like `mul_assoc`, which can be tricky when operating on many elements. \n\nSo `simp [mul_assoc]` is recommended. \n\n", "import algebra.group  -- hide\n", "import levels.group_props.level4 --hide\n", "variables {G : Type*} [group G] --hide \n", "namespace my_group  --hide\n", "For a group `G`, if `(a*b)*(a*b)=a*a*b*b` then `b*a=a*b`. \n", "end my_group --hide\n", "The code `simp,` tries to known theorems to simplify the goal. \n", "## Solution\n<details>\n  <summary>Solution Line 1</summary>\n        ` split,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `intro h,`\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `apply mul_right_cancel b,`\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw one_mul,`\n</details>\n<details>\n  <summary>Solution Line 5</summary>\n        `rw h,`\n</details>\n<details>\n  <summary>Solution Line 6</summary>\n        `intro h,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `rw h,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `rw one_mul,`\n</details>\n"]]}