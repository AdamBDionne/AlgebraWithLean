{"name": "Learning Lean Through Introductory Group Theory", "version": "1.0.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Learning Lean Through Introductory Group Theory-1.0.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 6, "objects": [{"type": "text", "content": "3"}, {"type": "lean", "content": "4", "hidden": false}, {"type": "lean", "content": "5", "hidden": true}, {"type": "lean", "content": "6", "hidden": false}, {"type": "lean", "content": "7", "hidden": true}, {"type": "text", "content": "8"}, {"type": "lemma", "text": "9", "lean": "theorem mul_left_cancel(a b c : G)(h1: a*b=a*c): b=c :=\n", "sideBar": true, "firstProofLineNumber": 42, "lastProofLineNumber": 45, "textBefore": "/-\n# Proving left cancellation.\n\n\nOur first goal is to prove that we have left cancellation in a group. \n\nMore precisely, given elements `a`, `b`, and `c` in our group $G$, if `a*b=a*c` then `b=c`. \n\nBut before we can do that, we need to know what axioms we are starting with. Lean defines a group as having associativity, an identity, and an inverse.#check\n\nIn particular, you can see the these properties written in Lean below. \n\n-/\n\n\nimport algebra.group \nvariables {G : Type*} [group G] -- hide\n\n#check (mul_assoc : \u2200 a b c : G, a * b * c = a * (b * c))\n#check (one_mul : \u2200 a : G, 1 * a = a)\n#check (mul_left_inv : \u2200 a : G, a\u207b\u00b9 * a = 1)\n\nnamespace my_group -- hide\n\n/- \nThe `#check` means we are asking Lean to check if these are true for our group `G`. And thankfully they are! \n\nWe will prove our first lemma, left cancellation, using these properties along with a single tactic: `rw`. \n\nThis tactic stands for rewrite. For example, if we had a hypothesis `h` that states `X=Y`, then `rw h,` would rewrite every `X` in our goal to a `Y`.\n\nFor example, I recommend the first line `rw \u2190 one_mul b,` which rewrites the goal `b=c` by replacing the `b` with `1*b`.\n\nThe left arrow symbol, `\u2190`, which you can get by writing `\\l`, reads the hypothesis in reverse. For example, `one_mul` says that `1*b=b` but we wanted to replace `b` with `1*b`, so we needed a `\u2190`.\n-/\n\n/- Lemma\nFor $a$, $b$, and $c$, in a group $G$, if `a*b=a*c` then `b=c`. \n-/\ntheorem mul_left_cancel(a b c : G)(h1: a*b=a*c): b=c :=\nbegin\n", "proof": "    sorry,\n\n\n", "textAfter": "\nend\nend my_group --hide\n/- Tactic : rw\nThe code `rw` rewrites our goal using a hypothesis `h`. For example, if our goal is `b=c` and we have the hypothesis `h: b=a`, then `rw h,` will get you `a=c`.\n\nRemember you can use `\u2190` to swith the order of the hypothesis. \n-/\n\n/-\n## Solution\nHere you can reveal the solution to this level, one line at a time. If stuck, I encourage you to only reveal upto the point you were stuck, and then try from there!\n\nFor this first level, I recommend liberal use of this solution! \n<details>\n  <summary>Solution Line 1</summary>\n        `rw \u2190 one_mul b,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `rw \u2190 mul_left_inv a,`\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `rw mul_assoc, `\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw h1,`\n</details>\n<details>\n  <summary>Solution Line 5</summary>\n        `rw \u2190 mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 6</summary>\n        `rw mul_left_inv,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `rw one_mul,`\n</details>\n-/\n", "height": 4, "editorText": "sorry", "lineOffset": 41, "name": "mul_left_cancel", "statement": "(a b c : G)(h1: a*b=a*c): b=c"}, {"type": "lean", "content": "10", "hidden": true}, {"type": "tactic", "content": "11", "name": "rw", "sideBar": true}, {"type": "text", "content": "12"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "text", "content": "13"}, {"type": "lean", "content": "14", "hidden": true}, {"type": "lean", "content": "15", "hidden": true}, {"type": "lean", "content": "16", "hidden": true}, {"type": "lean", "content": "17", "hidden": true}, {"type": "lemma", "text": "18", "lean": "theorem mul_one (a : G) : a * 1 = a :=\n", "sideBar": true, "firstProofLineNumber": 32, "lastProofLineNumber": 35, "textBefore": "/-\n# Using Apply to Prove Right Identity Multiplication.\n\n\nIn Lean, proving left cancellation is a very powerful result.\n\nThis is because it allows us to left multiply an equation by any element of the group.\n\nWe do this using the code `apply`. For example, if we have `a=b` then `apply mul_left_cancel c` will left multiply by `c`.\n\nTo demonstrate this, we will try to prove that `a*1=a` for all `a` in `G`. \n\nRemember, we don't know this yet, since our axiom only tells us that `1*a=a` for all `a` in `G`, but nothing about right hand side multiplication.\n\nFor the first line of code, I suggest `apply mul_left_cancel a\u207b\u00b9`, which multiplies both sides of `b=c` by `a\u207b\u00b9`. You can write `a\u207b\u00b9` by writing `a\\inv`.\n\nAgain, if you get stuck, the solution is below. Remember, the only tools we have right now are `rw`, `apply`, our axioms, and `mul_left_cancel`.\n\n-/\n\nimport algebra.group  -- hide\nimport levels.group_props.left_cancel --hide\nvariables {G : Type*} [group G] --hide \n\nnamespace my_group  --hide\n\n/- Lemma\nFor $a$, $b$, and $c$, in a group $G$, if `a*b=a*c` then `b=c`. \n-/\ntheorem mul_one (a : G) : a * 1 = a :=\nbegin\n", "proof": "    apply mul_left_cancel a\u207b\u00b9,\n    rw \u2190 mul_assoc,\n    rw mul_left_inv,\n    rw one_mul,", "textAfter": "\nend\nend my_group --hide\n\n/- Tactic : apply\nThe code `apply` lets us apply a theorem. For example, we have left cancellation: `a*b=a*c` implies `b=c`. So if we have `d=e` we can apply left cancellation in reverse and write `f*d=f*e` for any `f`.\n\nWe do this by `apply mul_left_cancel f,`.\n-/\n\n/-\n## Solution\n<details>\n  <summary>Solution Line 1</summary>\n        `apply mul_left_cancel a\u207b\u00b9,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `rw \u2190 mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `rw mul_left_inv,`\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw one_mul,`\n</details>\n-/", "height": 4, "editorText": "sorry", "lineOffset": 31, "name": "mul_one", "statement": "(a : G) : a * 1 = a"}, {"type": "lean", "content": "19", "hidden": true}, {"type": "tactic", "content": "20", "name": "apply", "sideBar": true}, {"type": "text", "content": "21"}]}]}], "texts": [["Learning Lean Through Introductory Group Theory", "# Learning Lean Through Introductory Group Theory, version 1.0.4.\n\n## By Adam Dionne\n\nOur goal today is to learn about Lean, a proof assistant programming language. To do so, we will be studying group theory.\n\nTo begin, click on the first level, \"Group Properties\", on the right hand side of the screen.\n\n# Credits\n\nThis website was constructed by the open source Lean Game Maker, found <a href=\"https://github.com/mpedramfar/Lean-game-maker\" target=\"blank\">here</a>.\n\n", "Group Properties", "# Proving left cancellation.\n\n\nOur first goal is to prove that we have left cancellation in a group. \n\nMore precisely, given elements `a`, `b`, and `c` in our group $G$, if `a*b=a*c` then `b=c`. \n\nBut before we can do that, we need to know what axioms we are starting with. Lean defines a group as having associativity, an identity, and an inverse.#check\n\nIn particular, you can see the these properties written in Lean below. \n\n", "import algebra.group \n", "variables {G : Type*} [group G] -- hide\n", "#check (mul_assoc : \u2200 a b c : G, a * b * c = a * (b * c))\n#check (one_mul : \u2200 a : G, 1 * a = a)\n#check (mul_left_inv : \u2200 a : G, a\u207b\u00b9 * a = 1)\n", "namespace my_group -- hide\n", "The `#check` means we are asking Lean to check if these are true for our group `G`. And thankfully they are! \n\nWe will prove our first lemma, left cancellation, using these properties along with a single tactic: `rw`. \n\nThis tactic stands for rewrite. For example, if we had a hypothesis `h` that states `X=Y`, then `rw h,` would rewrite every `X` in our goal to a `Y`.\n\nFor example, I recommend the first line `rw \u2190 one_mul b,` which rewrites the goal `b=c` by replacing the `b` with `1*b`.\n\nThe left arrow symbol, `\u2190`, which you can get by writing `\\l`, reads the hypothesis in reverse. For example, `one_mul` says that `1*b=b` but we wanted to replace `b` with `1*b`, so we needed a `\u2190`.\n", "For $a$, $b$, and $c$, in a group $G$, if `a*b=a*c` then `b=c`. \n", "end my_group --hide\n", "The code `rw` rewrites our goal using a hypothesis `h`. For example, if our goal is `b=c` and we have the hypothesis `h: b=a`, then `rw h,` will get you `a=c`.\n\nRemember you can use `\u2190` to swith the order of the hypothesis. \n", "## Solution\nHere you can reveal the solution to this level, one line at a time. If stuck, I encourage you to only reveal upto the point you were stuck, and then try from there!\n\nFor this first level, I recommend liberal use of this solution! \n<details>\n  <summary>Solution Line 1</summary>\n        `rw \u2190 one_mul b,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `rw \u2190 mul_left_inv a,`\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `rw mul_assoc, `\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw h1,`\n</details>\n<details>\n  <summary>Solution Line 5</summary>\n        `rw \u2190 mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 6</summary>\n        `rw mul_left_inv,`\n</details>\n<details>\n  <summary>Solution Line 7</summary>\n        `rw one_mul,`\n</details>\n", "# Using Apply to Prove Right Identity Multiplication.\n\n\nIn Lean, proving left cancellation is a very powerful result.\n\nThis is because it allows us to left multiply an equation by any element of the group.\n\nWe do this using the code `apply`. For example, if we have `a=b` then `apply mul_left_cancel c` will left multiply by `c`.\n\nTo demonstrate this, we will try to prove that `a*1=a` for all `a` in `G`. \n\nRemember, we don't know this yet, since our axiom only tells us that `1*a=a` for all `a` in `G`, but nothing about right hand side multiplication.\n\nFor the first line of code, I suggest `apply mul_left_cancel a\u207b\u00b9`, which multiplies both sides of `b=c` by `a\u207b\u00b9`. You can write `a\u207b\u00b9` by writing `a\\inv`.\n\nAgain, if you get stuck, the solution is below. Remember, the only tools we have right now are `rw`, `apply`, our axioms, and `mul_left_cancel`.\n\n", "import algebra.group  -- hide\n", "import levels.group_props.left_cancel --hide\n", "variables {G : Type*} [group G] --hide \n", "namespace my_group  --hide\n", "For $a$, $b$, and $c$, in a group $G$, if `a*b=a*c` then `b=c`. \n", "end my_group --hide\n", "The code `apply` lets us apply a theorem. For example, we have left cancellation: `a*b=a*c` implies `b=c`. So if we have `d=e` we can apply left cancellation in reverse and write `f*d=f*e` for any `f`.\n\nWe do this by `apply mul_left_cancel f,`.\n", "## Solution\n<details>\n  <summary>Solution Line 1</summary>\n        `apply mul_left_cancel a\u207b\u00b9,`\n</details>\n<details>\n  <summary>Solution Line 2</summary>\n        `rw \u2190 mul_assoc,`\n</details>\n<details>\n  <summary>Solution Line 3</summary>\n        `rw mul_left_inv,`\n</details>\n<details>\n  <summary>Solution Line 4</summary>\n        `rw one_mul,`\n</details>\n"]]}