{"name": "Learning Lean Through Introductory Group Theory", "version": "1.0.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Learning Lean Through Introductory Group Theory-1.0.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 5, "objects": [{"type": "text", "content": "3"}, {"type": "lean", "content": "4", "hidden": false}, {"type": "text", "content": "5"}, {"type": "lean", "content": "6", "hidden": false}, {"type": "text", "content": "7"}, {"type": "lemma", "text": "8", "lean": "theorem mul_left_cancel(a b c : G)(h1: a*b=a*c): b=c :=\n", "sideBar": true, "firstProofLineNumber": 38, "lastProofLineNumber": 44, "textBefore": "/-\n# Proving left cancellation.\n\n\nOur first goal is to prove that we have left cancellation in a group. \n\nMore precisely, given elements $a$, $b$, and $c$ in our group $G$, if `a*b=a*c` then `b=c`. \n\nBut before we can do that, we have to import our group and talk about what tools we have to start. So here is our first Lean code.\n\n\n-/\n\nimport algebra.group \nvariables {G : Type*} [group G] \n\n\n/- \nThe first line imports code that other people have written. Specifically, the code defines a group. \nIt defines a group with the following three axioms: associativity, an identity, and inverse. In Lean this looks like \n-/\n\n#check (mul_assoc : \u2200 a b c : G, a * b * c = a * (b * c))\n#check (one_mul : \u2200 a : G, 1 * a = a)\n#check (mul_left_inv : \u2200 a : G, a\u207b\u00b9 * a = 1)\n\nnamespace my_group \n\n/- \nThe second line defines the type of $G$ as a group: in essence, telling lean that $G$ is a group. \n-/\n\n/- Lemma\nFor $a$, $b$, and $c$, in a group $G$, if `a*b=a*c` then `b=c`. \n-/\ntheorem mul_left_cancel(a b c : G)(h1: a*b=a*c): b=c :=\nbegin\n", "proof": "    rw \u2190 one_mul b,\n    rw \u2190 mul_left_inv a,\n    rw mul_assoc, \n    rw h1, \n    rw \u2190 mul_assoc,\n    rw mul_left_inv,\n    rw one_mul,", "textAfter": "\nend\nend my_group ", "height": 7, "editorText": "sorry", "lineOffset": 37, "name": "mul_left_cancel", "statement": "(a b c : G)(h1: a*b=a*c): b=c"}, {"type": "lean", "content": "9", "hidden": false}]}]}], "texts": [["Learning Lean Through Introductory Group Theory", "# Learning Lean Through Introductory Group Theory, version 1.0.4.\n\n## By Adam Dionne\n\nOur goal today is to learn about Lean, a proof assistant programming language. To do so, we will be studying group theory.\n\nTo begin, click on the first level, \"Group Properties\", on the right hand side of the screen.\n\n# Credits\n\nThis website was constructed by the open source Lean Game Maker, found <a href=\"https://github.com/mpedramfar/Lean-game-maker\" target=\"blank\">here</a>.\n\n", "Group Properties", "# Proving left cancellation.\n\n\nOur first goal is to prove that we have left cancellation in a group. \n\nMore precisely, given elements $a$, $b$, and $c$ in our group $G$, if `a*b=a*c` then `b=c`. \n\nBut before we can do that, we have to import our group and talk about what tools we have to start. So here is our first Lean code.\n\n\n", "import algebra.group \nvariables {G : Type*} [group G] \n", "The first line imports code that other people have written. Specifically, the code defines a group. \nIt defines a group with the following three axioms: associativity, an identity, and inverse. In Lean this looks like \n", "#check (mul_assoc : \u2200 a b c : G, a * b * c = a * (b * c))\n#check (one_mul : \u2200 a : G, 1 * a = a)\n#check (mul_left_inv : \u2200 a : G, a\u207b\u00b9 * a = 1)\nnamespace my_group \n", "The second line defines the type of $G$ as a group: in essence, telling lean that $G$ is a group. \n", "For $a$, $b$, and $c$, in a group $G$, if `a*b=a*c` then `b=c`. \n", "end my_group "]]}